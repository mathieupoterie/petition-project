class Rectangle {
    constructor(w, h) { // this is a function for buildin the function Rectangle.
        this.width = w;
        this.height = h;
    } // no coma
    getArea() {
        return this.width * this.height;
    }
}

const rect = new Rectangle(5, 10); // always use new to invoke the constructor.

class Square extends Rectangle {
    constructor(n) {
        super(n, n);
        this.numSides = 4 ;
        // Rectangle is the super class of Square.
        // in a class constructed à partir d'une classe, this is undefined until we wall super.
    }
    getNumberSides(){ // here all squares will have it but not rectangle, because
        // square.prototype is created, inheritated of Rectangle.prototype
        console.log(super.getArea());// this refers to the Rectangle prototype.
        return this.numSides ;
    }
    getArea (){
        return super.getArea() + '!'
    }
    get area(){ // permet d'avoir quelque chose qui ressemble à des properties.
        return this.getArea();
    }
}

const square = new Square(5);


console.log(square.getArea(), square.getNumberSides());
console.log(rect.getArea());
console.log(rect.area);// this will looks like a property
console.log(typeof Rectangle); // class is a constructor function.
console.log(Rectangle.prototype.getArea); // we see here that the getArea function
// has all the function nested into the prototype. This is a shortcut syntax.




// Other thing :


class Person {
    set fullName(val) {
        val = val.split(' ');
        this.firstName = val[0];
        this.lastName =  val[1];
    }
    get fullName() {
        return [this.firstName, this.lastName].join(' ');
    }
}

const leo = new Person;
leo.fullName = 'Leonardo DiCaprio';
console.log(leo.firstName);

// A static function is a function that is attach to a prototype.
class Animal {
    static isAnimal(obj){
        return obj instanceof Animal;
    }

    // this is the same as :
    // Animal.isAnimal = function(obj){
    //     return obj instanceof Animal
    // }
}


console.log(Animal.isAnimal({}));
